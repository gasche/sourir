# The formal language

  P ::= Function main ()  ↦ F, (Df ↦ F)*   program:            main function and other functions
  F ::= (lᵥ ↦ V)*                          function body:      can contain multiple versions
  V ::= start ↦ i, I                       a function version: instruction stream with dedicated start
  I ::= (l ↦ i)*                           instruction stream: labeled instructions

Df ::= Function f (formal*)              function declaration (signature)

  x        variables

  f  function name
  l  branch label
  lᵥ version label

Reserved Names:
  main      main function    (execution of program starts here)
  start     start label      (execution of function starts here)

  formal ::=      formal argument
  | var x
  | mut x

  a  addresses

  i ::=    instructions
  | var x = e                     variable declaration
  | drop x                        drop a variable from scope
  | x <- e                        assignment
  | array x[e]                    array allocation
  | array x = [e₁, ..., eₙ]       array creation
  | x[e] <- e                     array assignment
  | branch e l₁ l₂                conditional
  | goto l                        goto
  | print e                       print
  | return e                      return
  | call x = e (arg*)             function call
  | osr(e, f, lᵥ, l, osr-map*)    osr : (can be used for osr-in and osr-out)

  arg ::= e | &x

A function argument is either an arbitrary expression `x` or `&x`,
which references a mutable variable `x`; the function declaration is
expecting a mutable variable `mut y` in this position, and `y` is
aliased to `x` from the caller environment; in particular, any
mutation of `y` within the function body will be visible on `x` after
the function has returned.

  e ::=     expression
  | se                    simple expression
  | primop(se*)           primitive operation
  | x[se]                 array index
  | length(se)             array length

  se ::=    simple expressions
  | lit                   literals
  | x                     variables
  | 'f                    function reference

  lit ::=  literals
  | nil
  | true | false
  | ... | -1 | 0 | 1 | 2 | ...

  v :=     values
  | lit                   literals
  | f                     function reference
  | a                     heap array address

  osr-map ::=    osr mapping declaration
  | var x = e

# Natural operational semantics

  E ::= (x ↦ v)*            lexical environment
  H ::= (a ↦ [v₁,...,vₙ])*  heap

  T ::= (lit)*                    output trace

## Configuration

  C ::= (x, E, I, l)                 continuation:  accumulator, environment, instructions, label

  M ::= (P, C*) : (I, T, H, E, l)    machine state: program, continuations : instructions, trace, heap, environment, pc

## Auxiliary functions

  succ I l =
   | goto l'                                -> [l']
   | branch _ l' l''                        -> [l', l'']
   | when I = {..., l -> _, l' -> _, ...}   -> [l']
   | _                                      -> []

  pred I l =
    { l' ∈ I : succ I l' = l }

## Evaluation of (simple) expressions:

  simple-eval P H E x   = E[x]
  simple-eval P H E lit = lit
  simple-eval P H E 'f  = f
    where Df ∈ dom P
      and Df  = Function f (formal*)

  eval P H E se          = simple-eval P H E se
  eval P H E primop(se*) = 〚primop〛(v*)
    where (v := simple-eval P H E se)*
  eval P H E x[se]       = vᵢ
    where a := E[x]
      and i := simple-eval P H E se
      and H[a] = [v₁, ..., vᵢ, ...]
  eval P H E length(se)   = n
    where a := simple-eval P H E se
      and H[a] = [v₁, ..., vₙ]

## One step reduction

  step   (var x = e) (P, I, T, H, E, l)
       = (I, T, H, E', succ I l)
   where v := eval P H E e
     and E' := E[x ↦ v]

  step   (x ← e) (P, I, T, H, E, l)
       = (I, T, H, E', succ I l)
    when v := eval P H E e
     and E' := E[x ↦ v]

  step   (drop x) (P, I, T, H, E, l)
       = (I, T, H, E', succ I l)
    when E' := E \ {x}

  step    (array x[e]) (P, I, T, H, E, l)
        = (I, T, H', E', succ I l)
   when a fresh
      n := eval P H E e
     H' := H[a ↦ [nil⁽ⁿ⁾]]
     E' := E[x ↦ a]

  step    (array x = [e₁, ..., eₙ]) (P, I, T, H, E, l)
        = (I, T, H', E', succ I l)
   when a fresh
     (vᵢ := eval P H E eᵢ)*
     H' := H[a ↦ [v₁, ..., vₙ]]
     E' := E[x ↦ a]

  step   (x[eᵢ] ← eₐ) (P, I, T, H, E, l)
       = (I, T, H', E, succ I l)
    when i := eval P H E eᵢ
     and v := eval P H E eₐ
     and a  := E[x]
     and H[a] = [v₁, ..., vᵢ, ...]
     and H' := H[a ↦ [v₁..., v, ...]]

  step   (print e) (P, I, T, H, E, l)
       = (I, (T, v), H, E, succ I l)
    when v := eval P H E e

  step   (branch e l₁ l₂) (P, I, T, H, E, l)
       = (I, T, H, E, l')
    when v  := eval P H E e
     and l' := if v = true  then l₁
               if v = false then l₂

  step   osr(e, f^, lᵥ^, l^, (osr-map*)) (P, I, T, H, E, l)
       = (I', T, H', E', l')
    when v := eval P H E e
     and if v = false then
         I' := I
         l' := l
         H' := H
         E' := E
     and if v = true then
         Df ∈ dom P
         Df  = Function f^ (formal*)
         I' := P(Df, lᵥ^)
         l' := l^
         (H', E') := replace-env osr-map

## Reduction relation '-->'

  (P, C*) : (I, T, H, E, l) --> (P, C*) : step I(l) (P, I, T, H, E, l)

  (P, C*) : (I, T, H, E, l) --> (P, (C*, C')) : (I', T, H', E', start)
    when I(l) = (call x = e (arg*))
     and f  := eval P H E e
     and Df ∈ dom P
     and Df  = Function f ((mod y)*)
     and I' := hd P(Df)
     and (H',E') := replace-env H E (mod y = arg)*
     and C' := (x, E, I, succ I l)

  (P, (C*, C')) : (I, T, H, E, l) --> (P, C*) : (I', T, H, E'', l')
    when I(l) = (return e)
     and v   := eval P H E e
     and C'   = (x', E', I', l')
     and E'' := E'[x' ↦ v]

# Scopes

declares i =
  | var x _
  | array x[e]
  | array x = [...]
  | call x = ...
                    -> [x]
  | _               -> []

requires i = bound_vars(i)

removes i =
  | drop x -> [x]
  | _      -> []

scope S ::= x*
scope assignment A ::= ((v, l) → S)*

## Scoping judgment

This judgment just classifies a valid scope assignment A for
a program P.

  ∀(v → M) ∈ P:   A, P ⊨d v → M
  ----------------------------
            A, P ⊨d

  ∀(l → i) ∈ M:   A, P ⊨d v, l → i
  -------------------------------
         A, P ⊨d v → M

  requires i ⊆ A(v,l)
  ∀l' ∈ succ(P(v),l),  A(v,l) ∪ declares i \ removes i = A(v,l')
  A, P ⊨d i : A(v,l)
  pred(P(v), l) = ∅  ⇒  i = start
  -----------------------------------------------------------
  A, P ⊨d v, l → i

The judgment (A, P ⊨d i : S) below is the instruction-specific judgment
that checks the scope restrictions that are specific to each
instruction, rather than the general control-flow constraints and the
generic requires/declares handling.

  -----------------
  A, P ⊨d start : ∅

              A(v', l') = x*
  -------------------------------------
  A, P ⊨d osr(e, f, lᵥ', l', (x = ee*)) : S

  ---------------
  A, P ⊨d stop : ∅

  i ∉ {start, osr, stop}
  ----------------------
  A, P ⊨d i : S

This strict scoping judgment is deterministic on reachable program
points: A is uniquely determined by P on those: start instructions
have to be in the empty scope, and then the scope of successors
instructions are uniquely determined. (This is thanks to `drop` that
lets us use equality instead of a superset relation there.)
